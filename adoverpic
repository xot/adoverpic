#!/usr/local/bin/python3
#
# adoverpic
#
# Author: Jaap-Henk Hoepman (info@xot.nl)
# Created: February 2020
#
# Extract LaTeX overpic commands from .eps files generated by Affinity Designer
#
# Usage:
#
# adoverpic <eps-in-file> <eps-out-file> <overpic-out-file>
#
# <eps-in-file> is a Affinity Designer generated .eps file. The contents of
# this file are copied to <eps-out-file> exept for text strings starting
# with \ . These are removed, and instead transformed into a LaTeX overpic
# command \put(x,y){\string} which is written to the file <overpic-out-file>
# using the x,y cooridnates found on the input
#
# MIT License
#
# Copyright (c) 2020 Jaap-Henk Hoepman
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


import sys, os, string, re

# LaTeX command is found on line that starts with '% '; the latex
# command itself is any string of non-space, non-newline characters that start
# with \
# In other words: any line that starts with '% \' and at least one more non
# whitespace character is considered to contain a LaTeX command
COMMAND_RE = re.compile (r'% \.([^ \n]+)')

# The coordinates are on a separate line following the command,
# as two real numbers (\ie can contain a dot) separated by a signle space
# (and followed by ' m', but we don't check that)
COORD_RE = re.compile (r'([0-9\.]+) ([0-9\.]+)') 

# EPS pts are not exactly LaTeX points
# EPS pt: 1 in = 72 pt; LaTeX point: 1 in = 72.27 pt;
EPSPTS_TO_LATEXPTS = 1.00375

def usage ():
    print("Usage: adoverpic <eps-in-file> <eps-out-file> <overpic-out-file>")

def error (msg):
    sys.stderr.write("adoverpic: error: %s\n" % msg)
    sys.exit (1)

# test if two fileanmes point to the same file
# (os.path.samefile throws exceptions for non-existing files)
def samefile(file1,file2):
    try:
        return os.path.samefile(file1,file2)
    except FileNotFoundError as e:
        return False
    
# skip to the end of the curves used to render the LaTeX command string
# (this is either a line with one single space, or, if it is the last
# thing to be rendered in the .eps file, a line with 'grestore')
def skipcurves(line,epsinf):
    while (line and (line != ' \n') and (line != ' grestore\n')):
        line = epsinf.readline()
    return line   

# A command was found on the current line; try to get the coordinates
# from the next line and write the corresponding overpic command
def processcommand(command,epsinf,overpicoutf):
    # get the coordinates from the next line
    line = epsinf.readline() 
    match = COORD_RE.search(line)
    if match:
        xcoord = match.group(1)
        ycoord = match.group(2)
        # convert to LaTeX points
        xcoord = float(xcoord) * EPSPTS_TO_LATEXPTS
        ycoord = float(ycoord) * EPSPTS_TO_LATEXPTS        
        # write out the overpic command with the found coordinates
        overpicoutf.write('\put(' + str(xcoord) + ',' + str(ycoord) + ')'
                          + '{\\' + command + '}\n')
        # and get the next line to process 
        line = epsinf.readline()
    else:
        error('no coordinates found: ' + line)
    return line

# process the input file one line at a time
def processfile(epsinf,epsoutf,overpicoutf):
    # read the first line
    line = epsinf.readline()
    # repeat until EOF, encoded as empty string; non-empty string is true
    while line: 
        # determine whether the line matches a LaTeX command
        match = COMMAND_RE.search(line)
        if match:
            # if the line contains a command, process it
            command = match.group(1)
            line = processcommand(command,epsinf,overpicoutf)
            # and skip the corresponding curves
            line = skipcurves(line,epsinf)
        else:
            # otherwise copy it, and move to the next line
            epsoutf.write(line)
            line = epsinf.readline()

# --- main ---

# test input arguments
if len (sys.argv) != 4:
    usage ()
    sys.exit (1)

# get arguments
epsinfile = sys.argv[1]
epsoutfile = sys.argv[2]
overpicoutfile = sys.argv[3]

# Check arguments to see if they refer to the same file
if samefile(epsinfile, epsoutfile):
    error('Input and output files must be different: '
          + epsinfile + ' = ' + epsoutfile)
if samefile(epsinfile, overpicoutfile):
    error('Input and output files must be different: '
          + epsinfile + ' = ' + overpicoutfile)
if samefile(epsoutfile, overpicoutfile):
    error('Output files must be different: '
          + epsoutfile + ' = ' + overpicoutfile)
    
# open the files
try:
    with open(epsinfile,'r') as epsinf:
        with open(epsoutfile,'w') as epsoutf:
            with open(overpicoutfile,'w') as overpicoutf:
                processfile(epsinf,epsoutf,overpicoutf)
except OSError as e:
    errno, strerr = e.args
    error(strerr + ": " +  e.filename)

    

                  
                
            

        


